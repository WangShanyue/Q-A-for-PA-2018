# 授课内容 PA3.2
作者：南京航空航天大学 计算机科学与技术学院 金航

未经作者允许，禁止转载

# 本节需要用到的参考资料
1. `INT 0x80参数表.pdf`
2. 仙剑奇侠传数据文件`pal.zip`

# 注意：本文中的`为什么`均可回答到报告中。

# 在操作系统上运行HelloWorld
我们在AM中输出的`HelloWorld`其实是通过AM提供的抽象接口来输出的，我们现在仍然能用，但是我们并不能使用`printf`函数，造成了极大不便。

## printf的前世今生
printf -> 对输出内容进行格式化 -> 调用封装了系统调用的`write`函数并赋予适当参数 -> 系统调用向`stdout`输出。

有兴趣可阅读`printf`函数的代码实现（在`ics2017\navy-apps\libs\libc\src\stdio\printf.c`中，牵扯到很多层字符串处理）

## 任务：实现标准输出
1. 编译`hello`程序，并修改`ramdisk`的生成规则，使`ramdisk`中的唯一文件变为`hello`程序。注意：**每次修改完代码尝试运行前，均需要进行`make update`来更新`ramdisk`**!
2. 运行。咦？为什么我的程序`并没有做write调用，就退出了呢`？还给了一个`BAD TRAP`。此时请你找到`_write()`这个函数看一下，所以现在我们需要修改它。
3. 修改成什么呢？请对比`_exit()`函数调用`_syscall_()`，想一想`SYS_write`调用的参数依次分别是什么呢？想不到？请查阅`man 2 write`。
4. 在`do_syscall`中识别系统调用`SYS_write`，并在该分支内写相应语句输出，其核心思想是循环调用`_putc`。注意：仅对于`fd`为`1`或`2`时，才进行字符输出，原因下面会讲。
5. 设定返回值，返回值代表什么？请查阅`man 2 write`。

## 特别提示
建议不要直接把代码写在`do_syscall()`的`switch`中的各个分支中，比较科学的建议写法是：
``` c
case SYS_write: ret = sys_write(各项参数); break;
```
其中`sys_write`是你自己起的函数名，意思就是为了后期可修改性，请你一定将各个系统调用的处理语句分别写成单独函数，否则后期可能会后悔。其余的系统调用的最终处理语句，也建议按此方法封装。

---

# 堆区管理
实际上，我们的`printf`并不是像上面那样是逐字符打印的，而是先将字符创格式化好，放进缓冲区中，缓冲区申请失败时，才是逐字符地打印。

## 程序间断点
我们知道真正的`loader`将程序读入内存后，程序相当于被拆解成很多部分放入虚拟内存的各个地址区域内，分为典型的如文本段（`Text Segment`），数据段（`Data Segment`），BSS段（`BSS Segment`），堆区（`Heap Memory`），栈区（`Stack Memory`），内核区（`Kernel Space`）等等。其中栈区从高地址向低地址增长，而堆区则从低地址向高地址增长。程序间断点（`Program Break`）指示的位置，即是堆区结束的位置。

## 堆区管理
堆区管理的函数：`malloc`和`free`函数。这两个函数的实质就是调用了`brk()`和`sbrk()`函数，前者通过**传递进来的地址参数来重新设定程序间断点位置**，后者通过**传递进来的增量参数调整程序间断点的位置**，而我们所说的程序间断点的位置，和堆区起始位置中间的部分，即为我们的**堆区**。我们并不需要知道上述几个函数怎么实现的（有兴趣可以看一看，就在`navy-apps`里面），然而我们需要实现`_sbrk`函数。

然而，上述的`brk()`和`sbrk()`，最终均落实为调用`_sbrk()`函数，该函数的管理算法如下：
1. `程序间断点`的起始位置为`_end`（也记作`原程序间断点`）
2. 计算`新程序间断点`的位置为`程序间断点位置+增量`。
3. 调用系统调用`SYS_brk`让OS设定`新程序间断点`（参数参见INT 0x80向量表）
4. 如果系统调用返回值为`0`，那么将`新程序间断点`设定为`程序间断点`（即修改`_end`），并返回`原程序间断点`
5. 如果系统调用返回值`不为0`，那么返回`-1`

## 任务：实现sbrk
1. 识别并实现`SYS_brk`，由于我们目前没有实现分时多任务，不存在空闲内存的分配问题，所以该系统调用只需要返回`0`即可。
2. 实现`_sbrk`函数，该函数的过程即上述的堆区管理算法。
3. 在`sys_write`中加入一句`Log`，观察实现`sbrk`前后，输出一次`Hello World`，分别调用多少次`write`系统调用。（要求将对比截图写入实验报告）

---

# 重点：简易文件系统
## 文件的本质
文件的实质就是按顺序排列在存储介质（如磁盘，ramdisk等）上的字节序列，两个文件之间并没有间隔（不考虑对齐时），而是通过`文件的起始位置（即在存储介质上的偏移）`和`文件的大小`相结合，得以寻找到一个文件，并用一个字符串来描述他，即我们熟知的`文件名`。

实际上，真正计算机中的文件系统文件并没有上述的这么简单，而是以`碎片`形式分散在磁盘中，然后通过`链表`将各个碎片串起来，看似像一个整个的文件。而我们实现非常简单。

我们的`简易文件系统`，只需要实现固定大小、固定位置上、固定数量个的文件即可，还不需要实现目录。因此我们就将文件直接逐个排列在`ramdisk`中就好了。

## 文件记录表
### 数据结构
一个结构体，拥有上述的三个成员变量。而我们的`Nanos-lite`已经为大家准备好了维护文件记录表的脚本，我们只需要修改一下`make update`的规则即可，让目录
```
navy-apps/fsimg/
```
下的文件也一并被放入生成的`ramdisk`映像中。此时的`make update`还具有生成文件记录表`nanos-lite/src/files.h`的功能。

修改前，根据`Makefile`中的规则可以看到，只是`touch`了一下`file.h`，并没有写什么进去。修改后，将文件列表写进了这个头文件中。

注意：虽然我们并没有实现目录功能，但是我们仍将文件放进目录中，并以`/目录/文件名`作为文件记录表中的文件名，相当于**将路径也看作了文件名的一部分**。

其实，我们在简化文件系统的过程中，还将文件打开后的`读写指针`也放入了`文件记录表`中。这个字段反映着当前**文件内**的偏移位置。

### 文件描述符
我们引入了一个编号的概念来标识各个文件，因为实际上并不是所有文件都有名字的，比如`stdin`，`stdout`和`stderr`。我们在简易文件系统中，**直接将文件在记录表中的数组下标**作为该文件的`文件描述符`。（问题：在`files.h`中的第一个文件就是`0`号文件吗？）

### 三个默认的文件描述符
``` c
#define FD_STDIN 0 // 标准输入 stdin
#define FD_STDOUT 1 // 标准输出 stdout
#define FD_STDERR 2 // 标准错误 stderr
```

## 文件的读写操作
各个库函数最终会调用`read/write/open/close`函数进行文件操作。而上述几个函数又会分别调用`_read/_write/_read/_write`函数，后者中又调用了`_syscall_`函数来编译出`INT 0x80`指令并设置好系统调用的寄存器参数。

陷入内核态后，经由`do_syscall`处理分发，识别出调用类型，再分别调用`sys_read/sys_write/sys_open/sys_close`，在这里面最终调用`fs_read/fs_write/fs_open/fs_close`，也就是我们要分别实现的这四个函数。

## 任务1：实现文件打开、读取和关闭
首先，修改`Makefile`的规则，使`fsimg`下的文件参与映像生成（到底有什么文件呢？自己看一下就知道了）。

写在哪里？`fs.c`，没有框架，需自己写函数，函数名及参数列表见`讲义`，其算法核心思想我们给出来了，看下面：

### fs_open()
我们的简易文件系统允许对所有文件进行读写，所以忽略文件打开方式的问题。

1. 找到指定文件名，跳2，否则跳3；
2. 将该项读写指针设为`0`，返回什么？查阅`man 2 open`
3. 没有找到文件，注意**一定要**直接`panic`掉程序。

### fs_read()
1. 必须先验证文件描述符`大于2`。为什么？
2. 根据传入文件号从文件记录表中找到对应记录；
3. 比较**要读的长度**和**剩余字节长度**（即总长度减去什么？）的大小，取其`大/小？`者为读的长度。为什么？可以回答到报告中。
3. 从`ramdisk`中对应地址处（这个地址等于谁和谁之和？）读这么多的数据到`buf`中；
4. 更新当前该文件的`读写指针`；
5. 返回一个值。这个值代表什么？查阅`man 2 read`。

### fs_close()
我们的简易文件系统并没有维护文件的打开状态，所以返回`？`表示成功关闭即可。请查阅`man 2 close`。

### fs_filesz()
这个函数不是系统调用，而是用来`返回给定文件号的文件大小`。

## 任务2：实现 Loader
在哪里实现？还记得吗？原来我们的实现是什么样子？现在引入了文件，应做什么修改呢？

1. 根据要执行的程序的文件名，如`/bin/hello`，得到文件号；
2. 用`fs_read`读得到的文件号的文件大小个字节，读到默认程序入口点附近；
3. 关闭文件；
4. 返回程序入口点。

实现完`Loader`之后，还需要在`loader()`的调用点传入可执行文件名。注意：`loader()`的第一个参数我们暂时涉及不到，传入`NULL`即可。

在改进后的`Loader`的基础上重新成功运行`/bin/hello`程序。此阶段`Loader`是直接通过读写`ramdisk`来打开并读文件的，因此暂不涉及系统调用分发。为什么不用`fopen`和`fread`？

## 任务3：实现写文件和移动读写指针
### fs_write()
1. 根据传入文件号从文件记录表中找到对应记录；
2. 比较**要写的长度**和**剩余字节长度**（即总长度减去什么？）的大小，取其`大/小？`者为写的长度。为什么？可以回答到报告中。
3. 判断文件号，文件号为`标准输出或标准错误`时，调用`_putc()`将待写的数据打印到屏幕上；
4. 否则往`ramdisk`的对应地址（这个地址等于谁和谁之和？）处写入这些数据。
5. 更新当前该文件的`读写指针`；
6. 返回值？请查阅`man 2 write`。

注意：我们前面实现过`sys_write()`，但是现在请你让该函数只做一件事情，那就是调用`fs_write`，因为我们将往屏幕打印的功能转移到`fs_write()`里面了，为了我们下一节要实现的设备抽象，请你务必这样做。

### fs_lseek()
该函数用于读写指针的**定位**。在开始写本函数前，请务必仔细阅读`man 2 lseek`，搞清楚`whence`参数的含义。然后看核心算法：
1. 根据传入文件号从文件记录表中找到对应记录；
2. 获得当前读写指针位置和当前文件的大小；
3. 根据`whence`参数的意义，计算出新的读写指针位置；
4. 注意保证新的读写指针位置**不能小于0，不能大于当前文件大小**，为什么？
5. 当新读写指针越界时，设置其到最靠近的那个边界（即当新读写指针小于`0`时，设置其为`0`；当大于文件大小时，应设置为什么呢？）。
6. 将新读写指针存入文件记录表中当前文件对应的项目的读写指针字段中；
7. 返回值是什么？请查阅`man 2 lseek`。

### 记得在`nanos.c`和`syscall.c`中添加对应的系统调用，包括`任务1`和`任务2`中的若干系统调用

### 成功运行程序`/bin/text`

## Nanos-lite 的代码文件组织
> 库函数最终调用各个系统调用的函数：ics2017/navy-apps/libs/libc/src/syscalls/
> 专门用于被编译成INT指令的函数（即对系统调用的封装）：ics2017/navy-apps/libs/libos/src/nanos.c
