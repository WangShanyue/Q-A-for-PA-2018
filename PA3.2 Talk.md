# 授课内容 PA3.2
作者：南京航空航天大学 计算机科学与技术学院 金航

未经作者允许，禁止转载

# 在操作系统上运行HelloWorld
我们在AM中输出的`HelloWorld`其实是通过AM提供的抽象接口来输出的，我们现在仍然能用，但是我们并不能使用`printf`函数，造成了极大不便。

## printf的前世今生
printf -> 对输出内容进行格式化 -> 调用封装了系统调用的`write`函数并赋予适当参数 -> 系统调用向`stdout`输出。

有兴趣可阅读`printf`函数的代码实现（在`ics2017\navy-apps\libs\libc\src\stdio\printf.c`中，牵扯到很多层字符串处理）

## 任务：实现标准输出
1. 编译`hello`程序，并修改`ramdisk`的生成规则，使`ramdisk`中的唯一文件变为`hello`程序。
2. 运行。咦？为什么我的程序`并没有做write调用，就退出了呢`？还给了一个`BAD TRAP`。此时请你找到`_write()`这个函数看一下，所以现在我们需要修改它。
3. 修改成什么呢？请对比`_exit()`函数调用`_syscall_()`，想一想`SYS_write`调用的参数依次分别是什么呢？想不到？请查阅`man 2 write`。
4. 在`do_syscall`中识别系统调用`SYS_write`，并在该分支内写相应语句输出，其核心思想是循环调用`_putc`。注意：仅对于`fd`为`1`或`2`时，才进行字符输出，原因下面会讲。
5. 设定返回值，返回值代表什么？请查阅`man 2 write`。

## 特别提示
建议不要直接把代码写在`do_syscall()`的`switch`中的各个分支中，比较科学的建议写法是：
``` c
case SYS_write: ret = sys_write(各项参数); break;
```
其中`sys_write`是你自己起的函数名，意思就是为了后期可修改性，请你一定将各个系统调用的处理语句分别写成单独函数，否则后期可能会后悔。其余的系统调用的最终处理语句，也建议按此方法封装。

---

# 堆区管理
实际上，我们的`printf`并不是像上面那样是逐字符打印的，而是先将字符创格式化好，放进缓冲区中，缓冲区申请失败时，才是逐字符地打印。

## 程序间断点
我们知道真正的`loader`将程序读入内存后，程序相当于被拆解成很多部分放入虚拟内存的各个地址区域内，分为典型的如文本段（`Text Segment`），数据段（`Data Segment`），BSS段（`BSS Segment`），堆区（`Heap Memory`），栈区（`Stack Memory`），内核区（`Kernel Space`）等等。其中栈区从高地址向低地址增长，而堆区则从低地址向高地址增长。程序间断点（`Program Break`）指示的位置，即是堆区结束的位置。

## 堆区管理
堆区管理的函数：`malloc`和`free`函数。这两个函数的实质就是调用了`brk()`和`sbrk()`函数，前者通过**传递进来的地址参数来重新设定程序间断点位置**，后者通过**传递进来的增量参数调整程序间断点的位置**，而我们所说的程序间断点的位置，和堆区起始位置中间的部分，即为我们的**堆区**。我们并不需要知道上述几个函数怎么实现的（有兴趣可以看一看，就在`navy-apps`里面），然而我们需要实现`_sbrk`函数。

然而，上述的`brk()`和`sbrk()`，最终均落实为调用`_sbrk()`函数，该函数的管理算法如下：
1. `程序间断点`的起始位置为`_end`（也记作`原程序间断点`）
2. 计算`新程序间断点`的位置为`程序间断点位置+增量`。
3. 调用系统调用`SYS_brk`让OS设定`新程序间断点`（参数参见INT 0x80向量表）
4. 如果系统调用返回值为`0`，那么将`新程序间断点`设定为`程序间断点`（即修改`_end`），并返回`原程序间断点`
5. 如果系统调用返回值`不为0`，那么返回`-1`

## 任务：实现sbrk
1. 识别并实现`SYS_brk`，由于我们目前没有实现分时多任务，不存在空闲内存的分配问题，所以该系统调用只需要返回`0`即可。
2. 实现`_sbrk`函数，该函数的过程即上述的堆区管理算法。
3. 在`sys_write`中加入一句`Log`，观察实现`sbrk`前后，输出一次`Hello World`，分别调用多少次`write`系统调用。（要求将对比截图写入实验报告）

---
未完待续
