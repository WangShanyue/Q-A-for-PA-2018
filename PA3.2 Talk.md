# 授课内容 PA3.2
作者：南京航空航天大学 计算机科学与技术学院 金航

未经作者允许，禁止转载

# 本节需要用到的参考资料
1. `INT 0x80参数表.pdf`
2. 仙剑奇侠传数据文件`pal.zip`

# 注意：本文中的`为什么`均可回答到报告中。

# 在操作系统上运行HelloWorld
我们在AM中输出的`HelloWorld`其实是通过AM提供的抽象接口来输出的，我们现在仍然能用，但是我们并不能使用`printf`函数，造成了极大不便。

## printf的前世今生
printf -> 对输出内容进行格式化 -> 调用封装了系统调用的`write`函数并赋予适当参数 -> 系统调用向`stdout`输出。

有兴趣可阅读`printf`函数的代码实现（在`ics2017\navy-apps\libs\libc\src\stdio\printf.c`中，牵扯到很多层字符串处理）

## 任务：实现标准输出
1. 编译`hello`程序，并修改`ramdisk`的生成规则，使`ramdisk`中的唯一文件变为`hello`程序。注意：**每次修改完代码尝试运行前，均需要进行`make update`来更新`ramdisk`**!
2. 运行。咦？为什么我的程序`并没有做write调用，就退出了呢`？还给了一个`BAD TRAP`。此时请你找到`_write()`这个函数看一下，所以现在我们需要修改它。
3. 修改成什么呢？请对比`_exit()`函数调用`_syscall_()`，想一想`SYS_write`调用的参数依次分别是什么呢？想不到？请查阅`man 2 write`。
4. 在`do_syscall`中识别系统调用`SYS_write`，并在该分支内写相应语句输出，其核心思想是循环调用`_putc`。注意：仅对于`fd`为`1`或`2`时，才进行字符输出，原因下面会讲。
5. 设定返回值，返回值代表什么？请查阅`man 2 write`。

## 特别提示
建议不要直接把代码写在`do_syscall()`的`switch`中的各个分支中，比较科学的建议写法是：
``` c
case SYS_write: ret = sys_write(各项参数); break;
```
其中`sys_write`是你自己起的函数名，意思就是为了后期可修改性，请你一定将各个系统调用的处理语句分别写成单独函数，否则后期可能会后悔。其余的系统调用的最终处理语句，也建议按此方法封装。

---

# 堆区管理
实际上，我们的`printf`并不是像上面那样是逐字符打印的，而是先将字符创格式化好，放进缓冲区中，缓冲区申请失败时，才是逐字符地打印。

## 程序间断点
我们知道真正的`loader`将程序读入内存后，程序相当于被拆解成很多部分放入虚拟内存的各个地址区域内，分为典型的如文本段（`Text Segment`），数据段（`Data Segment`），BSS段（`BSS Segment`），堆区（`Heap Memory`），栈区（`Stack Memory`），内核区（`Kernel Space`）等等。其中栈区从高地址向低地址增长，而堆区则从低地址向高地址增长。程序间断点（`Program Break`）指示的位置，即是堆区结束的位置。

## 堆区管理
堆区管理的函数：`malloc`和`free`函数。这两个函数的实质就是调用了`brk()`和`sbrk()`函数，前者通过**传递进来的地址参数来重新设定程序间断点位置**，后者通过**传递进来的增量参数调整程序间断点的位置**，而我们所说的程序间断点的位置，和堆区起始位置中间的部分，即为我们的**堆区**。我们并不需要知道上述几个函数怎么实现的（有兴趣可以看一看，就在`navy-apps`里面），然而我们需要实现`_sbrk`函数。

然而，上述的`brk()`和`sbrk()`，最终均落实为调用`_sbrk()`函数，该函数的管理算法如下：
1. `程序间断点`的起始位置为`_end`（也记作`原程序间断点`）
2. 计算`新程序间断点`的位置为`程序间断点位置+增量`。
3. 调用系统调用`SYS_brk`让OS设定`新程序间断点`（参数参见INT 0x80向量表）
4. 如果系统调用返回值为`0`，那么将`新程序间断点`设定为`程序间断点`（即修改`_end`），并返回`原程序间断点`
5. 如果系统调用返回值`不为0`，那么返回`-1`

## 任务：实现sbrk
1. 识别并实现`SYS_brk`，由于我们目前没有实现分时多任务，不存在空闲内存的分配问题，所以该系统调用只需要返回`0`即可。
2. 实现`_sbrk`函数，该函数的过程即上述的堆区管理算法。
3. 在`sys_write`中加入一句`Log`，观察实现`sbrk`前后，输出一次`Hello World`，分别调用多少次`write`系统调用。（要求将对比截图写入实验报告）

---

# 重点：简易文件系统
## 文件的本质
文件的实质就是按顺序排列在存储介质（如磁盘，ramdisk等）上的字节序列，两个文件之间并没有间隔（不考虑对齐时），而是通过`文件的起始位置（即在存储介质上的偏移）`和`文件的大小`相结合，得以寻找到一个文件，并用一个字符串来描述他，即我们熟知的`文件名`。

实际上，真正计算机中的文件系统文件并没有上述的这么简单，而是以`碎片`形式分散在磁盘中，然后通过`链表`将各个碎片串起来，看似像一个整个的文件。而我们实现非常简单。

我们的`简易文件系统`，只需要实现固定大小、固定位置上、固定数量个的文件即可，还不需要实现目录。因此我们就将文件直接逐个排列在`ramdisk`中就好了。

## 文件记录表
### 数据结构
一个结构体，拥有上述的三个成员变量。而我们的`Nanos-lite`已经为大家准备好了维护文件记录表的脚本，我们只需要修改一下`make update`的规则即可，让目录
```
navy-apps/fsimg/
```
下的文件也一并被放入生成的`ramdisk`映像中。此时的`make update`还具有生成文件记录表`nanos-lite/src/files.h`的功能。

修改前，根据`Makefile`中的规则可以看到，只是`touch`了一下`file.h`，并没有写什么进去。修改后，将文件列表写进了这个头文件中。

注意：虽然我们并没有实现目录功能，但是我们仍将文件放进目录中，并以`/目录/文件名`作为文件记录表中的文件名，相当于**将路径也看作了文件名的一部分**。

其实，我们在简化文件系统的过程中，还将文件打开后的`读写指针`也放入了`文件记录表`中。这个字段反映着当前**文件内**的偏移位置。

### 文件描述符
我们引入了一个编号的概念来标识各个文件，因为实际上并不是所有文件都有名字的，比如`stdin`，`stdout`和`stderr`。我们在简易文件系统中，**直接将文件在记录表中的数组下标**作为该文件的`文件描述符`。（问题：在`files.h`中的第一个文件就是`0`号文件吗？）

### 三个默认的文件描述符
``` c
#define FD_STDIN 0 // 标准输入 stdin
#define FD_STDOUT 1 // 标准输出 stdout
#define FD_STDERR 2 // 标准错误 stderr
```

## 文件的读写操作
各个库函数最终会调用`read/write/open/close`函数进行文件操作。而上述几个函数又会分别调用`_read/_write/_read/_write`函数，后者中又调用了`_syscall_`函数来编译出`INT 0x80`指令并设置好系统调用的寄存器参数。

陷入内核态后，经由`do_syscall`处理分发，识别出调用类型，再分别调用`sys_read/sys_write/sys_open/sys_close`，在这里面最终调用`fs_read/fs_write/fs_open/fs_close`，也就是我们要分别实现的这四个函数。

## 任务1：实现文件打开、读取和关闭
首先，修改`Makefile`的规则，使`fsimg`下的文件参与映像生成（到底有什么文件呢？自己看一下就知道了）。

写在哪里？`fs.c`，没有框架，需自己写函数，函数名及参数列表见`讲义`，其算法核心思想我们给出来了，看下面：

### fs_open()
我们的简易文件系统允许对所有文件进行读写，所以忽略文件打开方式的问题。

1. 找到指定文件名，跳2，否则跳3；
2. 将该项读写指针设为`0`，返回什么？查阅`man 2 open`
3. 没有找到文件，注意**一定要**直接`panic`掉程序。

### fs_read()
1. 必须先验证文件描述符`大于2`。为什么？
2. 根据传入文件号从文件记录表中找到对应记录；
3. 比较**要读的长度**和**剩余字节长度**（即总长度减去什么？）的大小，取其`大/小？`者为读的长度。为什么？可以回答到报告中。
3. 从`ramdisk`中对应地址处（这个地址等于谁和谁之和？）读这么多的数据到`buf`中；
4. 更新当前该文件的`读写指针`；
5. 返回一个值。这个值代表什么？查阅`man 2 read`。

### fs_close()
我们的简易文件系统并没有维护文件的打开状态，所以返回`？`表示成功关闭即可。请查阅`man 2 close`。

### fs_filesz()
这个函数不是系统调用，而是用来`返回给定文件号的文件大小`。

## 任务2：实现 Loader
在哪里实现？还记得吗？原来我们的实现是什么样子？现在引入了文件，应做什么修改呢？

1. 根据要执行的程序的文件名，如`/bin/hello`，得到文件号；
2. 用`fs_read`读得到的文件号的文件大小个字节，读到默认程序入口点附近；
3. 关闭文件；
4. 返回程序入口点。

实现完`Loader`之后，还需要在`loader()`的调用点传入可执行文件名。注意：`loader()`的第一个参数我们暂时涉及不到，传入`NULL`即可。

在改进后的`Loader`的基础上重新成功运行`/bin/hello`程序。此阶段`Loader`是直接通过读写`ramdisk`来打开并读文件的，因此暂不涉及系统调用分发。为什么不用`fopen`和`fread`？

## 任务3：实现写文件和移动读写指针
### fs_write()
1. 根据传入文件号从文件记录表中找到对应记录；
2. 比较**要写的长度**和**剩余字节长度**（即总长度减去什么？）的大小，取其`大/小？`者为写的长度。为什么？可以回答到报告中。
3. 判断文件号，文件号为`标准输出或标准错误`时，调用`_putc()`将待写的数据打印到屏幕上；
4. 否则往`ramdisk`的对应地址（这个地址等于谁和谁之和？）处写入这些数据。
5. 更新当前该文件的`读写指针`；
6. 返回值？请查阅`man 2 write`。

注意：我们前面实现过`sys_write()`，但是现在请你让该函数只做一件事情，那就是调用`fs_write`，因为我们将往屏幕打印的功能转移到`fs_write()`里面了，为了我们下一节要实现的设备抽象，请你务必这样做。

### fs_lseek()
该函数用于读写指针的**定位**。在开始写本函数前，请务必仔细阅读`man 2 lseek`，搞清楚`whence`参数的含义。然后看核心算法：
1. 根据传入文件号从文件记录表中找到对应记录；
2. 获得当前读写指针位置和当前文件的大小；
3. 根据`whence`参数的意义，计算出新的读写指针位置；
4. 注意保证新的读写指针位置**不能小于0，不能大于当前文件大小**，为什么？
5. 当新读写指针越界时，设置其到最靠近的那个边界（即当新读写指针小于`0`时，设置其为`0`；当大于文件大小时，应设置为什么呢？）。
6. 将新读写指针存入文件记录表中当前文件对应的项目的读写指针字段中；
7. 返回值是什么？请查阅`man 2 lseek`。

### 记得在`nanos.c`和`syscall.c`中添加对应的系统调用，包括`任务1`和`任务2`中的若干系统调用

### 成功运行程序`/bin/text`

## Nanos-lite 的代码文件组织
> 库函数最终调用各个系统调用的函数：ics2017/navy-apps/libs/libc/src/syscalls/
> 专门用于被编译成INT指令的函数（即对系统调用的封装）：ics2017/navy-apps/libs/libos/src/nanos.c

---

# 设备抽象
在`Linux`的世界里，我们的设备也被抽象成了一个个文件，可以去`/dev/`下看看。

## 为什么要抽象成文件？
设备和文件的关键共同点：都是**字节序列**。因此如果我们将设备视作文件，就可以用读写文件的方法对设备的访问进行封装，从而可以实现统一编程。

## 显示的抽象
输出到串口的数据已经被我们重定向到了`stdout`和`stderr`，所以我们现在已经可以往控制台上打印字符了。

然而屏幕显示呢？我们原本更新屏幕的方法？读写显存。

现在，我们要将**显存**抽象为一个**文件**，对这个文件进行写入，就是更新屏幕显示；与此同时，这个文件应支持**移动读写指针**，因为我们需要**往屏幕的各个位置写像素**，也就是往文件中不同的地方写数据。这个文件就是：
```
/dev/fb
```
屏幕的信息存储在
```
/proc/dispinfo
```
中。注意：以上两个文件你并不能在`fsimg`下找到（即不能在`ramdisk`中找到），因为它们是特殊的文件，我们需要在`fs_read()`和`fs_write()`中识别出`fd`为`FD_FB`的文件号，当且仅当对于这个文件号的读写操作，重定向到别的语句去处理。

## 任务：实现显存的抽象
### init_fs()
这个函数只有一行代码。将`/dev/fb`文件的大小设置为显存的大小即可。显存的大小如何计算？屏幕的点阵数乘以`？？`。屏幕的点阵数如何计算？使用`IOE`里面定义的屏幕信息的变量。

### fb_write()
两行代码可以解决。
1. 将传入的参数`offset`分解为横坐标和纵坐标（怎么分解？还记得一维数组和二维数组标号的数学关系吗？）
2. 调用画矩形函数`_draw_rect`，传入适当参数来把`buf`中内容写到要更新的显存区域中。

### init_device()
这个函数一共两行，其中一行框架帮我们写好了，是调用`_ioe_init`来初始化IOE。

需要我们做的事情仅仅是将屏幕信息按规定格式化地存入`dispinfo`字符串中。规定的格式？请见`navy-apps`下的`README.md`。

这里我强烈建议你再加一行代码将自己格式化的字符串内容用`Log()`打印出来，以判断自己做的对不对。

### dispinfo_read()
一行代码可以解决。要做的事情见讲义。

### 添加对上述两个特殊文件的支持
需要修改的地方包括：
1. 在`fs_read()`中识别出文件号为`FD_DISPINFO`的文件，这个文件号的文件通过调用`dispinfo_read`来读，而不是调用`ramdisk_read()`来读。
2. 在`fs_write()`中识别出文件号为`FD_FB`的文件，特别地，调用`fb_write(）`去写文件，而不是`ramdisk_write()`或是往屏幕上输出。

### 更换用户程序为`/bin/bmptest`并成功显示出图像

## 输入的抽象
我们目前有两个输入设备：`键盘`和`时钟`。我们将其抽象为文件的实质是让这两个设备把要输入的信息视作字节序列，然后我们去读字节序列即可。

这里，我们将`键盘`和`时钟`抽象为
```
/dev/events
```
这个文件，注意：这也是一个特殊的文件，你不能找到它的实体。它需要支持读文件操作。注意我们要优先读取键盘事件，因为不这样做的话就会被无数多个时钟事件所掩盖。

## 任务：实现输入的抽象
### events_read()
1. 调用`_read_key()`获得一个值；
2. 根据这个值检测出是通码还是断码，并分析出按的是哪个键；
3. 优先判断是否有键按下；
4. 如果有键按下按讲义上规定格式把按键信息格式化打印到字符串`buf`中并返回字符串长度**减1**，为什么？见讲义上的`bug提示`；
5. 如果没有键按下，则按规定格式将时间信息格式化打印到字符串`buf`中并返回字符串长度**减1**。

### 添加对这个特殊文件的支持
即在`fs_read()`中优先识别文件号是不是`FD_EVENTS`，如果是的话调用`events_read()`，其余不变。

## 最终任务：运行仙剑奇侠传
下载`pal.zip`并按讲义要求放到指定目录下，然后设定运行的程序为`/bin/pal`。

注意：运行时注意关掉`Nemu`项目中的`DEBUG`和`DIFF_TEST`两个宏，否则会很久都不能出现画面，操作也非常迟缓。

另外，我们在`PA2`中好像没有让大家实现`movs/movsb/movsw/movsd`指令，导致仙剑只能显示主菜单，选择新游戏进去会报没有实现指令。

### 实现`movs/movsb/movsw/movsd`指令
请严格参照`i386`手册实现这个指令。

### 开启新的故事
从主选单选择新的故事，将`李逍遥`和`李大娘`对话的画面截图，插入到本次的报告中，才算**完全**完成`最终任务`。

# 温馨提醒
记得回答`PA3.2`和`PA3.3`中的`思考题`以及章末的`必答题`，记得配上`Git Log`截图。

（完）
